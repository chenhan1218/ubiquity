#! /bin/sh

# This program handles OEM installations: it is run on the first boot after
# the end user receives the system, to configure settings specific to that
# end user.
#
# Modelled on base-config.

set -e

. /usr/share/debconf/confmodule

db_get debconf/priority
ORIG_PRIORITY="$RET"

usage () {
	cat <<EOF
Usage: firstboot [options]

Options:
  -i, --include ITEMS   Display only these (comma-separated) menu items.
  -e, --exclude ITEMS   Don't display these (comma-separated) menu items.
EOF
}

cleanup () {
	db_set debconf/priority "$ORIG_PRIORITY"
	exit 0
}

# Get an ordered list of the menu items.
get_menu_items () {
	(
		for i in $(find "$FB_LIBDIR/menu" \( -type f -or -type l \) -perm -700 -printf '%f\n'); do
			if [ -e "$FB_LIBDIR/menu/$i.mnu" ]; then
				echo "$(grep ^Order: "$FB_LIBDIR/menu/$i.mnu" | cut -f 2 -d ' ')" "$i"
			fi
		done
	) | sort -n | cut -d ' ' -f 2
}

in_item_list () {
	item="$1"
	list="$2"

	IFS_SAVE="$IFS"
	IFS=,
	for check in $list; do
		IFS="$IFS_SAVE"
		if [ "$item" = "$check" ]; then
			return 0
		fi
		IFS=,
	done
	IFS="$IFS_SAVE"

	return 1
}

# Set up to display the menu.
prep_menu () {
	SET_DEFAULT="$1"

	rm -f menu-mapping
	CHOICES=
	for item in $(get_menu_items); do
		# Always include the exit item. Otherwise, check includes
		# and excludes.
		if [ "$item" != exit ]; then
			if [ "$INCLUDE" ] && \
			   ! in_item_list "$item" "$INCLUDE"; then
				continue
			fi
			if [ "$EXCLUDE" ] && \
			   in_item_list "$item" "$EXCLUDE"; then
				continue
			fi
		fi

		testscript="$FB_LIBDIR/menu/${item%.mnu}.tst"
		if [ ! -x "$testscript" ] || "$testscript"; then
			db_metaget "firstboot/menu/$item" description || RET="$item"
			RET="$(echo "$RET" | sed -e 's/,//g' -e 's/  / /g')"
			echo "$RET,$item" >> menu-mapping
			if [ -z "$CHOICES" ]; then
				CHOICES="$RET"
				if [ "$SET_DEFAULT" -eq 1 ]; then
					# Mark first menu item as default to
					# get things going.
					db_set firstboot/main-menu "$RET"
				fi
			else
				CHOICES="$CHOICES, $RET"
			fi
		fi
	done

	db_subst firstboot/main-menu CHOICES "$CHOICES"
}

INCLUDE=
EXCLUDE=

if ! eval set -- "$(getopt -o i:e: -l help,include:,exclude: -- "$@")"; then
	usage >&2
	exit 1
fi

while :; do
	case $1 in
		--help)
			usage
			exit 0
			;;
		-i|--include)
			INCLUDE="$2"
			shift 2
			;;
		-e|--exclude)
			EXCLUDE="$2"
			shift 2
			;;
		--)	shift; break ;;
		*)	usage >&2; exit 1 ;;
	esac
done

# Set up to display the menu.
prep_menu 1

db_capb backup

ADVANCE=0

# Display the main menu.
while :; do
	# Title might get reset, so set it each time.
	db_settitle firstboot/title

	if [ "$ADVANCE" = 1 ]; then
		# Advance default to the next menu item.
		db_get firstboot/main-menu
		NEXT="$(grep -A 1 "^$RET," menu-mapping | cut -d , -f 1 | tail -n 1)"
		if [ "$NEXT" ]; then
			db_set firstboot/main-menu "$NEXT"
		fi
	fi
	ADVANCE=1

	db_fset firstboot/main-menu seen false
	if db_input medium firstboot/main-menu; then
		# Backing all the way out is the same as exiting firstboot.
		# However, note that I only go if the question will be
		# shown. Otherwise, debconf's auto-backup code could emulate
		# a backup based on a prior backup within a menu item.
		db_go || exit 30
	fi

	db_get firstboot/main-menu
	menu_item="$(grep "^$RET," menu-mapping | cut -d , -f 2)"

	# Set as unseen all questions that we're going to ask.
	if [ -e "asks/$menu_item" ]; then
		for name in $(< "asks/$menu_item"); do
			db_fset "$name" seen false
		done
	fi

	if ! "$FB_LIBDIR/menu/$menu_item"; then
		ADVANCE=0
		# Drop priority to make sure the menu is displayed, since a
		# menu item is failing.
		db_get debconf/priority
		if [ "$RET" = high ] || [ "$RET" = critical ]; then
			db_set debconf/priority medium
		fi
	elif grep -q 'Exit-Menu: true' "$FB_LIBDIR/menu/$menu_item.mnu"; then
		# This menu item finished the install, so exit the menu.
		cleanup
	else
		# Restore to the default priority, in case there was a
		# previous failure.
		db_set debconf/priority "$ORIG_PRIORITY"
	fi
done

cleanup
